{"version":3,"file":"storage-0fvgw0qx.js","sources":["../../src/storage.ts"],"sourcesContent":["import type { Folder, Prompt } from './types'\n\n// Storage keys\nexport const STORAGE_KEYS = {\n  FOLDERS: 'folders',\n  SYNC_ENABLED: 'syncEnabled',\n} as const\n\n// Storage schema version for future migrations\nexport const STORAGE_VERSION = 1\n\nexport interface StorageSchema {\n  version: number\n  folders: Folder[]\n  syncEnabled?: boolean\n}\n\nclass StorageManager {\n  private static instance: StorageManager\n  \n  private constructor() {}\n  \n  public static getInstance(): StorageManager {\n    if (!StorageManager.instance) {\n      StorageManager.instance = new StorageManager()\n    }\n    return StorageManager.instance\n  }\n\n  // Initialize storage with schema version\n  public async initialize(): Promise<void> {\n    const data = await chrome.storage.local.get(['version', STORAGE_KEYS.FOLDERS, STORAGE_KEYS.SYNC_ENABLED])\n    \n    if (!data.version || data.version < STORAGE_VERSION) {\n      // Initialize with empty data if no version exists\n      await this.setStorageData({\n        version: STORAGE_VERSION,\n        folders: data[STORAGE_KEYS.FOLDERS] || [],\n        syncEnabled: data[STORAGE_KEYS.SYNC_ENABLED] || false\n      })\n    }\n  }\n\n  // Get all folders\n  public async getFolders(): Promise<Folder[]> {\n    const data = await chrome.storage.local.get(STORAGE_KEYS.FOLDERS)\n    return data[STORAGE_KEYS.FOLDERS] || []\n  }\n\n  // Save to cloud\n  public async saveToCloud(): Promise<void> {\n    const folders = await this.getFolders();\n    try {\n      await chrome.storage.sync.set({ [STORAGE_KEYS.FOLDERS]: folders });\n    } catch (error) {\n      console.error('Failed to save to cloud:', error);\n      throw error;\n    }\n  }\n\n  // Load from cloud\n  public async loadFromCloud(): Promise<void> {\n    try {\n      const data = await chrome.storage.sync.get(STORAGE_KEYS.FOLDERS);\n      const cloudFolders = data[STORAGE_KEYS.FOLDERS] || [];\n      await this.saveFolders(cloudFolders);\n    } catch (error) {\n      console.error('Failed to load from cloud:', error);\n      throw error;\n    }\n  }\n\n  // Save folders\n  public async saveFolders(folders: Folder[]): Promise<void> {\n    // Validate folder structure before saving\n    this.validateFolders(folders)\n    await chrome.storage.local.set({\n      [STORAGE_KEYS.FOLDERS]: folders\n    })\n  }\n\n  // Export folders to JSON file\n  public async exportFolders(): Promise<void> {\n    const folders = await this.getFolders()\n    const dataStr = JSON.stringify(folders, null, 2)\n    const dataBlob = new Blob([dataStr], { type: 'application/json' })\n    const url = URL.createObjectURL(dataBlob)\n    \n    const downloadLink = document.createElement('a')\n    downloadLink.href = url\n    downloadLink.download = `RCP-backup-${new Date().toISOString().split('T')[0]}.json`\n    const favicon = document.querySelector('link[rel=\"icon\"]') as HTMLLinkElement\n    if (favicon) {\n      downloadLink.setAttribute('data-icon', favicon.href)\n    }\n    document.body.appendChild(downloadLink)\n    downloadLink.click()\n    document.body.removeChild(downloadLink)\n    URL.revokeObjectURL(url)\n  }\n\n  // Import folders from JSON file\n  public async importFolders(file: File): Promise<{ success: boolean; error?: string }> {\n    try {\n      const text = await file.text()\n      \n      // First try to parse the JSON\n      let folders\n      try {\n        folders = JSON.parse(text)\n      } catch (e) {\n        return {\n          success: false,\n          error: 'Invalid JSON format. Please make sure your backup file is a valid JSON file.'\n        }\n      }\n      \n      // Validate the imported data structure\n      if (!Array.isArray(folders)) {\n        return {\n          success: false,\n          error: 'Invalid backup format. The file should contain an array of folders.'\n        }\n      }\n      \n      // Validate each folder and its prompts\n      for (const folder of folders) {\n        if (!folder.id || typeof folder.id !== 'string') {\n          return {\n            success: false,\n            error: `Invalid folder structure: missing or invalid 'id' in folder \"${folder.name || 'unnamed'}\"`\n          }\n        }\n        \n        if (!folder.name || typeof folder.name !== 'string') {\n          return {\n            success: false,\n            error: `Invalid folder structure: missing or invalid 'name' in folder with ID \"${folder.id}\"`\n          }\n        }\n        \n        if (!Array.isArray(folder.prompts)) {\n          return {\n            success: false,\n            error: `Invalid folder structure: 'prompts' must be an array in folder \"${folder.name}\"`\n          }\n        }\n        \n        for (const prompt of folder.prompts) {\n          if (!prompt.id || typeof prompt.id !== 'string') {\n            return {\n              success: false,\n              error: `Invalid prompt structure: missing or invalid 'id' in prompt \"${prompt.title || 'unnamed'}\" in folder \"${folder.name}\"`\n            }\n          }\n          \n          if (!prompt.title || typeof prompt.title !== 'string') {\n            return {\n              success: false,\n              error: `Invalid prompt structure: missing or invalid 'title' in prompt with ID \"${prompt.id}\" in folder \"${folder.name}\"`\n            }\n          }\n          \n          if (!prompt.text || typeof prompt.text !== 'string') {\n            return {\n              success: false,\n              error: `Invalid prompt structure: missing or invalid 'text' in prompt \"${prompt.title}\" in folder \"${folder.name}\"`\n            }\n          }\n          \n          if (!prompt.timestamp || typeof prompt.timestamp !== 'string' || isNaN(Date.parse(prompt.timestamp))) {\n            return {\n              success: false,\n              error: `Invalid prompt structure: missing or invalid 'timestamp' in prompt \"${prompt.title}\" in folder \"${folder.name}\"`\n            }\n          }\n        }\n      }\n      \n      // If all validation passes, save the folders\n      await this.saveFolders(folders)\n      return { success: true }\n    } catch (error) {\n      console.error('Error importing folders:', error)\n      return {\n        success: false,\n        error: 'An unexpected error occurred while importing folders. Please check the console for details.'\n      }\n    }\n  }\n\n  // Import prompt package without replacing existing folders\n  public async importPromptPackage(file: File): Promise<{ success: boolean; error?: string; message?: string }> {\n    try {\n      const text = await file.text()\n      \n      // First try to parse the JSON\n      let folders\n      try {\n        folders = JSON.parse(text)\n      } catch (e) {\n        return {\n          success: false,\n          error: 'Invalid JSON format. Please make sure your package file is a valid JSON file.'\n        }\n      }\n      \n      // Validate the imported data structure\n      if (!Array.isArray(folders)) {\n        return {\n          success: false,\n          error: 'Invalid package format. The file should contain an array of folders.'\n        }\n      }\n      \n      // Validate each folder and its prompts (reusing existing validation logic)\n      for (const folder of folders) {\n        if (!folder.id || typeof folder.id !== 'string') {\n          return {\n            success: false,\n            error: `Invalid folder structure: missing or invalid 'id' in folder \"${folder.name || 'unnamed'}\"`\n          }\n        }\n        \n        if (!folder.name || typeof folder.name !== 'string') {\n          return {\n            success: false,\n            error: `Invalid folder structure: missing or invalid 'name' in folder with ID \"${folder.id}\"`\n          }\n        }\n        \n        if (!Array.isArray(folder.prompts)) {\n          return {\n            success: false,\n            error: `Invalid folder structure: 'prompts' must be an array in folder \"${folder.name}\"`\n          }\n        }\n        \n        // Additional validation for prompts\n        for (const prompt of folder.prompts as Prompt[]) {\n          if (!prompt.id || typeof prompt.id !== 'string') {\n            return {\n              success: false,\n              error: `Invalid prompt structure: missing or invalid 'id' in prompt \"${prompt.title || 'unnamed'}\" in folder \"${folder.name}\"`\n            }\n          }\n          \n          if (!prompt.title || typeof prompt.title !== 'string') {\n            return {\n              success: false,\n              error: `Invalid prompt structure: missing or invalid 'title' in prompt with ID \"${prompt.id}\" in folder \"${folder.name}\"`\n            }\n          }\n          \n          if (!prompt.text || typeof prompt.text !== 'string') {\n            return {\n              success: false,\n              error: `Invalid prompt structure: missing or invalid 'text' in prompt \"${prompt.title}\" in folder \"${folder.name}\"`\n            }\n          }\n          \n          if (!prompt.timestamp || typeof prompt.timestamp !== 'string' || isNaN(Date.parse(prompt.timestamp))) {\n            return {\n              success: false,\n              error: `Invalid prompt structure: missing or invalid 'timestamp' in prompt \"${prompt.title}\" in folder \"${folder.name}\"`\n            }\n          }\n        }\n      }\n      \n      // Get existing folders\n      const existingFolders = await this.getFolders()\n      \n      // Filter out any existing imported folders\n      const regularFolders = existingFolders.filter(f => !f.isImported)\n      const currentImportedFolders = existingFolders.filter(f => f.isImported)\n      \n      // Generate new IDs for imported folders and prompts to avoid conflicts\n      const importedFolders = folders.map(folder => ({\n        ...folder,\n        id: crypto.randomUUID(),\n        name: folder.name,\n        isImported: true, // Mark as imported\n        prompts: folder.prompts.map((prompt: Prompt) => ({\n          ...prompt,\n          id: crypto.randomUUID()\n        }))\n      }))\n      \n      // Combine regular folders first, then all imported folders\n      const newFolders = [...regularFolders, ...currentImportedFolders, ...importedFolders]\n      \n      // Save the combined folders\n      await this.saveFolders(newFolders)\n      return { \n        success: true,\n        message: `Successfully imported ${importedFolders.length} folder${importedFolders.length === 1 ? '' : 's'}`\n      }\n    } catch (error) {\n      console.error('Error importing prompt package:', error)\n      return {\n        success: false,\n        error: 'An unexpected error occurred while importing the prompt package. Please check the console for details.'\n      }\n    }\n  }\n\n  // Set complete storage data\n  private async setStorageData(data: StorageSchema): Promise<void> {\n    await chrome.storage.local.set(data)\n  }\n\n  // Validate folder structure\n  private validateFolders(folders: Folder[]): void {\n    if (!Array.isArray(folders)) {\n      throw new Error('Folders must be an array')\n    }\n\n    folders.forEach(folder => {\n      if (!folder.id || typeof folder.id !== 'string') {\n        throw new Error('Each folder must have a valid string ID')\n      }\n      if (!folder.name || typeof folder.name !== 'string') {\n        throw new Error('Each folder must have a valid string name')\n      }\n      if (!Array.isArray(folder.prompts)) {\n        throw new Error('Folder prompts must be an array')\n      }\n\n      folder.prompts.forEach(prompt => {\n        if (!prompt.id || typeof prompt.id !== 'string') {\n          throw new Error('Each prompt must have a valid string ID')\n        }\n        if (!prompt.title || typeof prompt.title !== 'string') {\n          throw new Error('Each prompt must have a valid string title')\n        }\n        if (!prompt.text || typeof prompt.text !== 'string') {\n          throw new Error('Each prompt must have valid string text')\n        }\n        if (!prompt.timestamp || typeof prompt.timestamp !== 'string') {\n          throw new Error('Each prompt must have a valid timestamp')\n        }\n      })\n    })\n  }\n\n  // Clear all storage data\n  public async clearStorage(): Promise<void> {\n    await chrome.storage.local.clear()\n    await this.initialize()\n  }\n\n  // Toggle sync functionality\n  public async toggleSync(enabled: boolean): Promise<void> {\n    await chrome.storage.local.set({ [STORAGE_KEYS.SYNC_ENABLED]: enabled })\n    \n    if (enabled) {\n      // If enabling sync, try to sync with cloud immediately\n      try {\n        const syncData = await chrome.storage.sync.get(STORAGE_KEYS.FOLDERS)\n        if (syncData[STORAGE_KEYS.FOLDERS]) {\n          await this.saveFolders(syncData[STORAGE_KEYS.FOLDERS])\n        } else {\n          // If no cloud data exists, push local data to cloud\n          const localData = await this.getFolders()\n          await chrome.storage.sync.set({ [STORAGE_KEYS.FOLDERS]: localData })\n        }\n      } catch (error) {\n        console.error('Error during initial sync:', error)\n        throw error\n      }\n    }\n  }\n}\n\n// Export a singleton instance\nexport const storageManager = StorageManager.getInstance()\n"],"names":["STORAGE_KEYS","STORAGE_VERSION","_StorageManager","data","folders","error","cloudFolders","dataStr","dataBlob","url","downloadLink","favicon","file","text","folder","prompt","existingFolders","regularFolders","f","currentImportedFolders","importedFolders","newFolders","enabled","syncData","localData","__publicField","StorageManager","storageManager"],"mappings":"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"}
{"version":3,"file":"background.ts-CCbuNN7g.js","sources":["../../src/types.ts","../../src/background.ts"],"sourcesContent":["/**\n * Represents a prompt in the extension.\n */\nexport interface Prompt {\n  /** Unique identifier for the prompt */\n  id: string\n  /** Title of the prompt */\n  title: string\n  /** Text content of the prompt */\n  text: string\n  /** Creation timestamp in ISO 8601 format (created using toISOString()) */\n  timestamp: string\n  /** Whether the prompt was imported from an external source */\n  isImported?: boolean\n}\n\n/**\n * Represents a folder containing prompts.\n */\nexport interface Folder {\n  /** Unique identifier for the folder */\n  id: string\n  /** Name of the folder */\n  name: string\n  /** Array of prompts in the folder */\n  prompts: Prompt[]\n  /** Whether the folder was imported from an external source */\n  isImported?: boolean\n}\n\n/**\n * Interface for generating context menu IDs.\n */\nexport interface ContextMenuIds {\n  /** ID of the parent context menu */\n  parent: string\n  /** Function to generate a context menu ID for a folder */\n  folder: (folderId: string) => string\n  /** Function to generate a context menu ID for a prompt */\n  prompt: (promptId: string) => string\n}\n\n/**\n * Represents the data stored in the extension's storage.\n */\nexport interface Storage {\n  /** Array of folders containing prompts */\n  folders: Folder[]\n  /** Theme preference object with isDark boolean property */\n  theme: { isDark: boolean }\n  /** Whether instant paste is enabled */\n  instaPaste: boolean\n}\n\nexport const CONTEXT_MENU_IDS: ContextMenuIds = {\n  parent: 'rightClickPrompt',\n  folder: (folderId: string) => `folder_${folderId}`,\n  prompt: (promptId: string) => `prompt_${promptId}`\n}\n","import type { Folder } from \"./types\"\nimport type { Prompt } from \"./types\"\nimport { CONTEXT_MENU_IDS } from \"./types\"\nimport { storageManager } from \"./storage\"\n\n// Type augmentation for global interfaces\ndeclare global {\n  interface Window {\n    CodeMirror?: any;\n    monaco?: {\n      editor: {\n        getEditors(): any[];\n      }\n    };\n    ace?: any;\n    tinymce?: {\n      activeEditor?: {\n        insertContent(content: string): void;\n      }\n    };\n    CKEDITOR?: {\n      instances: {\n        [key: string]: {\n          insertText(text: string): void;\n        }\n      }\n    };\n  }\n  \n  interface Element {\n    isContentEditable?: boolean;\n    CodeMirror?: any;\n  }\n}\n\nconst toastMessages = [\n  \"Prompt copied to clipboard. Ready to paste!\",\n  \"Prompt copied. Your clipboard is ready for use.\",\n  \"Copied! Use this prompt where you need it.\",\n  \"Your prompt is copied to clipboard.\",\n  \"Prompt copied to clipboard.\",\n  \"Prompt copied: Ready to use.\",\n  \"Success! Prompt copied to clipboard.\",\n  \"Clipboard updated with your prompt.\",\n  \"Prompt copied and ready to use.\",\n  \"Prompt copied to clipboard.\",\n  \"Prompt copied successfully.\",\n  \"Your prompt is now on your clipboard.\",\n  \"Prompt copied to clipboard.\",\n  \"Prompt copied. Ready to use.\",\n  \"Prompt now in your clipboard.\",\n  \"Prompt copied to clipboard.\",\n  \"Prompt copied successfully.\",\n  \"Prompt ready to paste.\",\n  \"Prompt copied to clipboard.\",\n  \"Clipboard updated with prompt.\",\n  \"Prompt copied to clipboard.\",\n  \"Prompt copied and ready to use.\",\n  \"Prompt copied to clipboard.\"\n];\n\nfunction getRandomToastMessage() {\n  // Always return regular message\n  return toastMessages[Math.floor(Math.random() * toastMessages.length)];\n}\n\nasync function showToastOnActiveTab(message: string) {\n  try {\n    const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n    if (!tab?.id) {\n      console.log(\"No active tab found for toast notification\");\n      return;\n    }\n\n    // Check if the URL is restricted\n    if (tab.url && (\n      tab.url.startsWith('chrome://') ||\n      tab.url.startsWith('chrome-extension://') ||\n      tab.url.startsWith('devtools://') ||\n      tab.url.startsWith('edge://') ||\n      tab.url.startsWith('about:')\n    )) {\n      // Use badge notification for restricted URLs instead\n      console.log(\"Using badge notification for restricted URL:\", tab.url);\n      chrome.action.setBadgeText({ text: \"✓\" });\n      chrome.action.setBadgeBackgroundColor({ color: \"#EF4444\" });\n      setTimeout(() => {\n        chrome.action.setBadgeText({ text: \"\" });\n      }, 2000);\n      return;\n    }\n\n    // Check if we have scripting permission\n    const hasScripting = await chrome.permissions.contains({\n      permissions: ['scripting']\n    });\n\n    if (hasScripting) {\n      // Show toast using scripting\n      try {\n        await chrome.scripting.executeScript({\n          target: { tabId: tab.id ?? -1 },\n        func: (msg: string) => {\n            // Define a unique ID for toast tracking\n            const TOAST_ID = 'rcp-toast-notification';\n            \n            // Clean up any existing toasts first\n            const cleanup = () => {\n              const existingToasts = document.querySelectorAll('.rcp-toast');\n              existingToasts.forEach(toast => {\n                if (toast.parentNode) {\n                  try {\n                    document.body.removeChild(toast);\n                  } catch (e: unknown) {\n                    console.error('Error removing toast:', e);\n                  }\n                }\n              });\n              \n              // Also try removing by ID\n              const existingToastById = document.getElementById(TOAST_ID);\n              if (existingToastById && existingToastById.parentNode) {\n                try {\n                  existingToastById.parentNode.removeChild(existingToastById);\n                } catch (e: unknown) {\n                  console.error('Error removing toast by ID:', e);\n                }\n              }\n            };\n            \n            // Clean up first\n            cleanup();\n            \n            // Create new toast\n          const toast = document.createElement('div');\n            toast.id = TOAST_ID;\n            toast.className = 'rcp-toast';\n            \n            // Create icon element with SVG instead of emoji\n            const iconSpan = document.createElement('span');\n            iconSpan.className = 'rcp-toast-icon';\n            \n            // Use the RCP icon SVG\n            iconSpan.innerHTML = `\n              <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 200 200\" width=\"20\" height=\"20\">\n                <!-- White outline around the whole logo (slightly larger) -->\n                <polygon points=\"100,36 155,68 155,132 100,164 45,132 45,68\" fill=\"none\" stroke=\"white\" stroke-width=\"4\" />\n                \n                <!-- White background inside hexagon -->\n                <polygon points=\"100,40 152,70 152,130 100,160 48,130 48,70\" fill=\"white\" />\n                \n                <!-- Outer node white outlines -->\n                <circle cx=\"100\" cy=\"40\" r=\"13.5\" fill=\"white\" stroke=\"white\" stroke-width=\"3\" />\n                <circle cx=\"152\" cy=\"70\" r=\"13.5\" fill=\"white\" stroke=\"white\" stroke-width=\"3\" />\n                <circle cx=\"152\" cy=\"130\" r=\"13.5\" fill=\"white\" stroke=\"white\" stroke-width=\"3\" />\n                <circle cx=\"100\" cy=\"160\" r=\"13.5\" fill=\"white\" stroke=\"white\" stroke-width=\"3\" />\n                <circle cx=\"48\" cy=\"130\" r=\"13.5\" fill=\"white\" stroke=\"white\" stroke-width=\"3\" />\n                <circle cx=\"48\" cy=\"70\" r=\"13.5\" fill=\"white\" stroke=\"white\" stroke-width=\"3\" />\n                \n                <!-- Lines connecting nodes -->\n                <line x1=\"100\" y1=\"100\" x2=\"100\" y2=\"40\" stroke=\"black\" stroke-width=\"5\" />\n                <line x1=\"100\" y1=\"100\" x2=\"100\" y2=\"160\" stroke=\"black\" stroke-width=\"5\" />\n                <line x1=\"100\" y1=\"100\" x2=\"152\" y2=\"70\" stroke=\"black\" stroke-width=\"5\" />\n                <line x1=\"100\" y1=\"100\" x2=\"152\" y2=\"130\" stroke=\"black\" stroke-width=\"5\" />\n                <line x1=\"100\" y1=\"100\" x2=\"48\" y2=\"70\" stroke=\"black\" stroke-width=\"5\" />\n                <line x1=\"100\" y1=\"100\" x2=\"48\" y2=\"130\" stroke=\"black\" stroke-width=\"5\" />\n                \n                <!-- Outer hexagon connections -->\n                <line x1=\"100\" y1=\"40\" x2=\"152\" y2=\"70\" stroke=\"black\" stroke-width=\"5\" />\n                <line x1=\"152\" y1=\"70\" x2=\"152\" y2=\"130\" stroke=\"black\" stroke-width=\"5\" />\n                <line x1=\"152\" y1=\"130\" x2=\"100\" y2=\"160\" stroke=\"black\" stroke-width=\"5\" />\n                <line x1=\"100\" y1=\"160\" x2=\"48\" y2=\"130\" stroke=\"black\" stroke-width=\"5\" />\n                <line x1=\"48\" cy=\"130\" x2=\"48\" y2=\"70\" stroke=\"black\" stroke-width=\"5\" />\n                <line x1=\"48\" y1=\"70\" x2=\"100\" y2=\"40\" stroke=\"black\" stroke-width=\"5\" />\n                \n                <!-- Outer nodes (black) -->\n                <circle cx=\"100\" cy=\"40\" r=\"12\" fill=\"black\" />\n                <circle cx=\"152\" cy=\"70\" r=\"12\" fill=\"black\" />\n                <circle cx=\"152\" cy=\"130\" r=\"12\" fill=\"black\" />\n                <circle cx=\"100\" cy=\"160\" r=\"12\" fill=\"black\" />\n                <circle cx=\"48\" cy=\"130\" r=\"12\" fill=\"black\" />\n                <circle cx=\"48\" cy=\"70\" r=\"12\" fill=\"black\" />\n                \n                <!-- Center node (red) -->\n                <circle cx=\"100\" cy=\"100\" r=\"14\" fill=\"#FF3333\" stroke=\"black\" stroke-width=\"5\" />\n              </svg>\n            `;\n            \n            // Create text span for message\n            const textSpan = document.createElement('span');\n            textSpan.className = 'rcp-toast-text';\n            textSpan.innerText = msg;\n            \n            // Append icon and text to toast\n            toast.appendChild(iconSpan);\n            toast.appendChild(textSpan);\n            \n            // Apply position styles with !important to override any site CSS\n            Object.assign(toast.style, {\n              position: 'fixed',\n              top: '20px',\n              bottom: 'auto !important',\n              left: '50%',\n              right: 'auto',\n              transform: 'translateX(-50%)',\n              background: '#2D2D2D', // Dark gray background\n              color: '#FFFFFF', // White text\n              padding: '10px 16px',\n              borderRadius: '8px',\n              zIndex: '2147483647',\n              boxShadow: '0 4px 12px rgba(0, 0, 0, 0.25)',\n              fontWeight: '500',\n              fontSize: '14px',\n              borderLeft: '4px solid #EF4444', // Red accent\n              opacity: '0',\n              margin: '0',\n              display: 'flex', // Use flexbox for layout\n              alignItems: 'center', // Center items vertically\n              gap: '8px', // Space between icon and text\n              transition: 'opacity 200ms ease-out, transform 200ms ease-out',\n              textAlign: 'center',\n            });\n            \n            // Style the icon\n            Object.assign(iconSpan.style, {\n              fontSize: '16px',\n              display: 'flex',\n              alignItems: 'center',\n              justifyContent: 'center',\n              width: '20px',\n              height: '20px',\n              marginRight: '4px'\n            });\n            \n            // Add !important to critical styles\n            toast.setAttribute('style', toast.getAttribute('style') + \n              'position: fixed !important; top: 20px !important; bottom: auto !important;' +\n              'left: 50% !important; transform: translateX(-50%) !important;' + \n              'z-index: 2147483647 !important; background: #2D2D2D !important; color: #FFFFFF !important;' +\n              'display: flex !important; align-items: center !important; text-align: center !important;');\n            \n          document.body.appendChild(toast);\n            \n            // Force layout reflow for animation\n            void toast.offsetWidth;\n            \n            // Set opacity instantly - already added transition in initial styles\n            toast.style.opacity = '1';\n            toast.style.transform = 'translateX(-50%)';\n            \n            // Schedule removal - more reliable fade-out and removal\n            const removeToast = () => {\n              // Start fade out\n              toast.style.opacity = '0';\n              toast.style.transform = 'translateX(-50%) translateY(-10px)'; // Use translateX to maintain centering\n              toast.setAttribute('style', toast.getAttribute('style') + \n                'opacity: 0 !important; transform: translateX(-50%) translateY(-10px) !important;'); // Ensure centering maintained\n              \n              // Remove element after transition\n              setTimeout(() => {\n                if (toast.parentNode) {\n                  try {\n                    document.body.removeChild(toast);\n                  } catch (e: unknown) {\n                    console.error('Error removing toast after timeout:', e);\n                  }\n                }\n              }, 250); // Slightly faster removal after fade starts\n            };\n            \n            // Set exact 2 second timeout for toast visibility\n            const toastTimer = setTimeout(removeToast, 2000);\n            \n            // Force cleanup after 2.5 seconds as a fallback\n            const backupTimer = setTimeout(() => {\n              clearTimeout(toastTimer); // Clear the main timer if it hasn't fired yet\n              if (toast.parentNode) {\n                try {\n                  document.body.removeChild(toast);\n                } catch (e: unknown) {\n                  console.error('Error in backup toast removal:', e);\n                }\n              }\n            }, 2500);\n            \n            // Ensure timers are cleared if the page changes\n            window.addEventListener('beforeunload', () => {\n              clearTimeout(toastTimer);\n              clearTimeout(backupTimer);\n              cleanup();\n            }, { once: true });\n            \n            // Return the toast element\n            return toast;\n        },\n        args: [message]\n      });\n      } catch (e) {\n        console.log(\"Toast script execution failed, using badge fallback:\", e);\n        // Fallback to badge notification\n        chrome.action.setBadgeText({ text: \"✓\" });\n        chrome.action.setBadgeBackgroundColor({ color: \"#EF4444\" });\n        setTimeout(() => {\n          chrome.action.setBadgeText({ text: \"\" });\n        }, 2000);\n      }\n    } else {\n      // Fallback: show badge notification\n      chrome.action.setBadgeText({ text: \"✓\" });\n      chrome.action.setBadgeBackgroundColor({ color: \"#EF4444\" });\n      setTimeout(() => {\n        chrome.action.setBadgeText({ text: \"\" });\n      }, 2000);\n    }\n  } catch (error: unknown) {\n    console.error('Error showing toast:', error);\n    // Final fallback: ensure badge notification\n    try {\n      chrome.action.setBadgeText({ text: \"✓\" });\n      chrome.action.setBadgeBackgroundColor({ color: \"#EF4444\" });\n      setTimeout(() => {\n        chrome.action.setBadgeText({ text: \"\" });\n      }, 2000);\n    } catch (e) {\n      console.error('Even badge fallback failed:', e);\n    }\n  }\n}\n\n// Function to copy text to clipboard using different methods\nasync function copyToClipboard(text: string): Promise<boolean> {\n  try {\n    // Try using the Clipboard API directly\n    if (navigator.clipboard && navigator.clipboard.writeText) {\n      try {\n        await navigator.clipboard.writeText(text);\n        return true;\n      } catch (e) {\n        console.log(\"Direct clipboard API failed, trying fallback methods\", e);\n        // Continue to fallback methods\n      }\n    }\n    \n    // Check if we're in a background script context where navigator.clipboard might not be available,\n    // or if the active tab is a restricted URL\n    const [activeTab] = await chrome.tabs.query({ active: true, currentWindow: true });\n    \n    // Skip restricted URLs\n    if (activeTab?.url && (\n        activeTab.url.startsWith('chrome://') || \n        activeTab.url.startsWith('chrome-extension://') ||\n        activeTab.url.startsWith('devtools://') ||\n        activeTab.url.startsWith('edge://') ||\n        activeTab.url.startsWith('about:')\n      )) {\n      // Use background script clipboard API as fallback for restricted URLs\n      // Note: This may still fail depending on browser permissions\n      try {\n        if (navigator.clipboard) {\n          await navigator.clipboard.writeText(text);\n          return true;\n        }\n      } catch (e) {\n        console.error(\"Unable to copy in restricted URL context:\", e);\n        return false;\n      }\n    }\n    \n    // For regular URLs, try using executeScript\n    if (activeTab?.id) {\n      // Check if we have scripting permission\n      const hasPermission = await chrome.permissions.contains({\n        permissions: ['scripting', 'activeTab']\n      });\n      \n      if (hasPermission) {\n        try {\n          const result = await chrome.scripting.executeScript({\n            target: { tabId: activeTab.id ?? -1 },\n            func: (textToCopy: string) => {\n              // This runs in the context of the page\n              try {\n                // Try using Clipboard API first\n                if (navigator.clipboard && navigator.clipboard.writeText) {\n                  navigator.clipboard.writeText(textToCopy);\n                  return true;\n                }\n                \n                // Fallback to execCommand\n                const textarea = document.createElement('textarea');\n                textarea.value = textToCopy;\n                textarea.style.position = 'fixed';\n                textarea.style.opacity = '0';\n                document.body.appendChild(textarea);\n                textarea.select();\n                const success = document.execCommand('copy');\n                document.body.removeChild(textarea);\n                return success;\n              } catch (e) {\n                console.error(\"In-page clipboard operation failed:\", e);\n                return false;\n              }\n            },\n            args: [text]\n          });\n          \n          return result && result[0] && result[0].result === true;\n        } catch (e) {\n          console.error(\"Script execution for clipboard failed:\", e);\n          // Continue to try other methods\n        }\n      }\n    }\n    \n    // If all else fails, return false\n    return false;\n  } catch (error: unknown) {\n    console.error('Error copying to clipboard:', error);\n    return false;\n  }\n}\n\n// Function to rebuild context menu\nasync function rebuildContextMenu() {\n  // Remove existing menu items\n  await chrome.contextMenus.removeAll();\n\n  // Create parent menu\n  chrome.contextMenus.create({\n    id: CONTEXT_MENU_IDS.parent,\n    title: \"Right Click Prompt\",\n    contexts: [\"all\"]\n  });\n\n  // Get folders from storage\n  const folders = await storageManager.getFolders();\n\n  // Separate regular and imported folders\n  const regularFolders = folders.filter(f => !f.isImported);\n  const importedFolders = folders.filter(f => f.isImported);\n\n  // Create menu items for regular folders\n  if (regularFolders.length > 0) {\n    chrome.contextMenus.create({\n      id: 'regular_prompts_header',\n      parentId: CONTEXT_MENU_IDS.parent,\n      title: 'My Prompts',\n      type: 'normal',\n      enabled: false,\n      contexts: [\"all\"]\n    });\n\n    regularFolders.forEach(folder => {\n      // Create folder submenu\n      chrome.contextMenus.create({\n        id: CONTEXT_MENU_IDS.folder(folder.id),\n        parentId: CONTEXT_MENU_IDS.parent,\n        title: folder.name,\n        contexts: [\"all\"]\n      });\n\n      // Create menu items for each prompt in the folder\n      folder.prompts.forEach(prompt => {\n        chrome.contextMenus.create({\n          id: CONTEXT_MENU_IDS.prompt(prompt.id),\n          parentId: CONTEXT_MENU_IDS.folder(folder.id),\n          title: prompt.title,\n          contexts: [\"all\"]\n        });\n      });\n    });\n  }\n\n  // Create menu items for imported folders\n  if (importedFolders.length > 0) {\n    // Add separator\n    chrome.contextMenus.create({\n      id: 'separator',\n      type: 'separator',\n      parentId: CONTEXT_MENU_IDS.parent,\n      contexts: [\"all\"]\n    });\n\n    // Add imported prompts header\n    chrome.contextMenus.create({\n      id: 'imported_prompts_header',\n      parentId: CONTEXT_MENU_IDS.parent,\n      title: 'Imported Prompts',\n      type: 'normal',\n      enabled: false,\n      contexts: [\"all\"]\n    });\n\n    importedFolders.forEach(folder => {\n      // Create folder submenu\n      chrome.contextMenus.create({\n        id: CONTEXT_MENU_IDS.folder(folder.id),\n        parentId: CONTEXT_MENU_IDS.parent,\n        title: folder.name,\n        contexts: [\"all\"]\n      });\n\n      // Create menu items for each prompt in the folder\n      folder.prompts.forEach(prompt => {\n        chrome.contextMenus.create({\n          id: CONTEXT_MENU_IDS.prompt(prompt.id),\n          parentId: CONTEXT_MENU_IDS.folder(folder.id),\n          title: prompt.title,\n          contexts: [\"all\"]\n        });\n      });\n    });\n  }\n\n  // Save Selection as Prompt feature temporarily removed\n}\n\n// Initialize extension on install or update\nchrome.runtime.onInstalled.addListener(async (details) => {\n  // Now rebuild context menu after setting auto-paste\n  await rebuildContextMenu();\n  \n  // Show a usage tip notification for new installs\n  if (details.reason === 'install') {    \n    // Check if we've shown the tip before\n    const result = await chrome.storage.local.get(['hasSeenRightClickTip']);\n    if (!result.hasSeenRightClickTip) {\n      // Create a notification\n      chrome.action.setBadgeText({ text: \"TIP\" });\n      chrome.action.setBadgeBackgroundColor({ color: \"#4f46e5\" });\n      \n      // Show a toast on the first active tab if we have permission\n      try {\n        // First check if we have scripting permission\n        const hasPermission = await chrome.permissions.contains({\n          permissions: ['scripting', 'activeTab']\n        });\n        \n        if (hasPermission) {\n          const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n          if (tabs && tabs.length > 0 && tabs[0]?.id) {\n            // Make sure the tab id is valid and the URL is not a restricted one\n            const tabId = tabs[0].id;\n            const url = tabs[0].url || '';\n            \n            // Skip restricted URLs\n            if (!url.startsWith('chrome://') && \n                !url.startsWith('chrome-extension://') && \n                !url.startsWith('devtools://') && \n                !url.startsWith('edge://') && \n                !url.startsWith('about:')) {\n              \n              try {\n                await chrome.scripting.executeScript({\n                  target: { tabId },\n                  func: () => {\n                    // Create toast element\n                    const toast = document.createElement('div');\n                    toast.style.position = 'fixed';\n                    toast.style.bottom = '20px';\n                    toast.style.right = '20px';\n                    toast.style.backgroundColor = '#4f46e5';\n                    toast.style.color = 'white';\n                    toast.style.padding = '12px 16px';\n                    toast.style.borderRadius = '6px';\n                    toast.style.zIndex = '9999';\n                    toast.style.fontSize = '14px';\n                    toast.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';\n                    toast.style.maxWidth = '300px';\n                    toast.innerHTML = '<b>RCP Tip:</b> Right-click anywhere to access your saved prompts!';\n                    \n                    // Add to page\n                    document.body.appendChild(toast);\n                    \n                    // Remove after 8 seconds\n                    setTimeout(() => {\n                      if (document.body.contains(toast)) {\n                        document.body.removeChild(toast);\n                      }\n                    }, 8000);\n                  }\n                });\n              } catch (scriptError) {\n                console.error('Error executing script in tab:', scriptError);\n              }\n            }\n          }\n        }\n      } catch (e) {\n        console.error('Error showing tip:', e);\n      }\n      \n      // Mark as seen\n      await chrome.storage.local.set({ hasSeenRightClickTip: true });\n      \n      // Clear badge after 5 seconds\n      setTimeout(() => {\n        chrome.action.setBadgeText({ text: \"\" });\n      }, 5000);\n    }\n  }\n});\n\n// Listen for storage changes to update context menu\nchrome.storage.onChanged.addListener((changes) => {\n  if (changes.folders) {\n    rebuildContextMenu()\n  }\n})\n\n// Handle context menu clicks\nchrome.contextMenus.onClicked.addListener(async (info) => {\n  console.log('Context menu clicked:', info.menuItemId);\n  \n  // Handle \"Save Selection as Prompt\"\n  if (info.menuItemId === \"savePrompt\" && info.selectionText) {\n    const title = prompt(\"Enter a title for this prompt:\")\n    if (!title?.trim()) return\n\n    const result = await chrome.storage.local.get('folders')\n    const folders: Folder[] = result.folders || []\n    \n    // If there are no folders, create a default one\n    if (folders.length === 0) {\n      folders.push({\n        id: crypto.randomUUID(),\n        name: \"Default\",\n        prompts: []\n      })\n    }\n    \n    // Add prompt to the first folder\n    folders[0].prompts.push({\n      id: crypto.randomUUID(),\n      title: title.trim(),\n      text: info.selectionText,\n      timestamp: new Date().toISOString()\n    })\n    \n    await storageManager.saveFolders(folders)\n    \n    // Show a notification\n    chrome.action.setBadgeText({ text: \"!\" })\n    chrome.action.setBadgeBackgroundColor({ color: \"#10B981\" })\n    \n    setTimeout(() => {\n      chrome.action.setBadgeText({ text: \"\" })\n    }, 2000)\n  }\n  // Handle prompt selection\n  else if (typeof info.menuItemId === 'string') {\n    // Check if the menuItemId matches the prompt pattern\n    const match = info.menuItemId.match(/^prompt_(.+)$/);\n    if (match) {\n      const promptId = match[1];\n      const folders = await storageManager.getFolders();\n      \n      // Find the prompt in all folders\n      let foundPrompt = null;\n    for (const folder of folders) {\n        const prompt = folder.prompts.find(p => p.id === promptId);\n      if (prompt) {\n          foundPrompt = prompt;\n          break;\n        }\n      }\n      \n      if (foundPrompt) {\n        try {\n          // Get autoPaste setting\n          const result = await chrome.storage.local.get(['autoPaste']);\n          const isAutoPasteEnabled = result.autoPaste ?? false;\n          \n          // Copy to clipboard (always do this as a fallback)\n          const copied = await copyToClipboard(foundPrompt.text);\n          \n          // If autoPaste is enabled, try to paste the text directly\n          if (isAutoPasteEnabled) {\n            try {\n              // Check if we have scripting permission\n              const hasScripting = await chrome.permissions.contains({\n                permissions: ['scripting', 'activeTab']\n              });\n              \n              if (hasScripting) {\n                // Get active tab\n                const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n                \n                if (tab?.id) {\n                  // Skip restricted URLs\n                  if (tab.url && (\n                    tab.url.startsWith('chrome://') ||\n                    tab.url.startsWith('chrome-extension://') ||\n                    tab.url.startsWith('devtools://') ||\n                    tab.url.startsWith('edge://') ||\n                    tab.url.startsWith('about:')\n                  )) {\n                    // Use clipboard notification for restricted URLs\n                    showToastOnActiveTab(getRandomToastMessage());\n            return;\n          }\n\n                  // Execute script to paste text with preserved formatting\n                  const results = await chrome.scripting.executeScript({\n                    target: { tabId: tab.id },\n                    func: (text: string): boolean => {\n                      // Improved function to insert text with better formatting preservation\n                      const insertTextWithFormatting = (text: string): boolean => {\n                        // Get active element\n                        const activeElement = document.activeElement;\n                        \n                        if (activeElement && \n                            (activeElement.isContentEditable || \n                             activeElement.tagName === 'TEXTAREA' || \n                             (activeElement.tagName === 'INPUT' && \n                              ['text', 'search', 'url', 'tel', 'password'].includes((activeElement as HTMLInputElement).getAttribute('type') || '')))) {\n                          \n                          if (activeElement.isContentEditable) {\n                            // Check the white-space property to decide how to handle line breaks\n                            const computedStyle = window.getComputedStyle(activeElement);\n                            const whiteSpace = computedStyle.whiteSpace;\n                            \n                            if (whiteSpace === 'pre' || whiteSpace === 'pre-wrap' || whiteSpace === 'pre-line') {\n                              // For pre-formatted elements, preserve line breaks as-is\n                              const success = document.execCommand('insertText', false, text);\n                              if (!success) {\n                                // Fallback: Use Selection API if execCommand fails\n                                const selection = window.getSelection();\n                                if (selection && selection.rangeCount > 0) {\n                                  const range = selection.getRangeAt(0);\n                                  range.deleteContents();\n                                  const textNode = document.createTextNode(text);\n                                  range.insertNode(textNode);\n                                  range.setStartAfter(textNode);\n                                  range.setEndAfter(textNode);\n                      return true;\n                    }\n                    return false;\n                              }\n                              return true;\n                      } else {\n                              // For elements that don't preserve whitespace, convert newlines to <br>\n                              const formattedText = text\n                                .replace(/&/g, '&amp;')\n                                .replace(/</g, '&lt;')\n                                .replace(/>/g, '&gt;')\n                                .replace(/\\n/g, '<br>')\n                                .replace(/\\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;')\n                                .replace(/ {2}/g, '&nbsp;&nbsp;');\n                              \n                              const success = document.execCommand('insertHTML', false, formattedText);\n                              return success;\n                            }\n                          } \n                          else if (activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'INPUT') {\n                            // For textarea/input, we can use selection API\n                            const inputElement = activeElement as HTMLInputElement | HTMLTextAreaElement;\n                      const start = inputElement.selectionStart || 0;\n                      const end = inputElement.selectionEnd || 0;\n                            const value = inputElement.value;\n                            \n                            // Insert text at cursor position, preserving line breaks\n                            inputElement.value = value.substring(0, start) + text + value.substring(end);\n                            \n                            // Move cursor to end of inserted text\n                            inputElement.selectionStart = inputElement.selectionEnd = start + text.length;\n                            \n                            // Trigger input event to notify the application of changes\n                            const inputEvent = new Event('input', { bubbles: true });\n                            const changeEvent = new Event('change', { bubbles: true });\n                            inputElement.dispatchEvent(inputEvent);\n                            inputElement.dispatchEvent(changeEvent);\n                            \n                            return true;\n                          }\n                        }\n                        \n                        // Try handling common rich text editors\n                        // 1. Check for Monaco Editor (VS Code, many web IDEs)\n                      if (window.monaco && window.monaco.editor) {\n                        const editors = window.monaco.editor.getEditors();\n                        if (editors && editors.length > 0) {\n                            const editor = editors[0]; // Use first editor\n                          editor.trigger('keyboard', 'type', { text });\n                            return true;\n                          }\n                        }\n                        \n                        // 2. Check for CodeMirror (many code editors)\n                        if (window.CodeMirror) {\n                          // Find the CodeMirror instance\n                          let cmInstance = null;\n                          \n                          // Try to get from active element first\n                          if (activeElement && activeElement.CodeMirror) {\n                            cmInstance = activeElement.CodeMirror;\n            } else {\n                            // Try to find CodeMirror in the document\n                            const cmElements = document.querySelectorAll('.CodeMirror');\n                            if (cmElements.length > 0) {\n                              cmInstance = cmElements[0].CodeMirror;\n                            }\n                          }\n                          \n                          if (cmInstance) {\n                            const doc = cmInstance.getDoc();\n                            const cursor = doc.getCursor();\n                            doc.replaceRange(text, cursor);\n                            return true;\n                          }\n                        }\n                        \n                        // 3. Check for Ace Editor (used in many web IDEs)\n                        if (window.ace && window.ace.edit) {\n                          const aceEditor = window.ace.edit(document.querySelector('.ace_editor'));\n                          if (aceEditor) {\n                            aceEditor.insert(text);\n                            return true;\n                          }\n                        }\n                        \n                        // 4. Check for TinyMCE (used in many WYSIWYG editors)\n                        if (window.tinymce && window.tinymce.activeEditor) {\n                          window.tinymce.activeEditor.insertContent(text);\n                          return true;\n                        }\n                        \n                        // 5. Check for CKEditor\n                        if (window.CKEDITOR) {\n                          for (const instanceName in window.CKEDITOR.instances) {\n                            const instance = window.CKEDITOR.instances[instanceName];\n                            instance.insertText(text);\n                            return true;\n                          }\n                        }\n                        \n                        // Fallback: try to use document.execCommand for active element\n                        try {\n                          const success = document.execCommand('insertText', false, text);\n                          if (success) return true;\n                          } catch (e) {\n                          console.error('execCommand insert failed:', e);\n                        }\n                        \n                        return false;\n                      };\n                      \n                      // Try to insert text with formatting\n                      return insertTextWithFormatting(text);\n                    },\n                    args: [foundPrompt.text]\n                  });\n\n                  const pasteSuccess = results && results[0] && results[0].result === true;\n                  \n                  // Only show toast notification if paste fails\n                  if (!pasteSuccess) {\n                    showToastOnActiveTab(getRandomToastMessage());\n                  }\n                  } else {\n                  // No active tab, fallback to clipboard notification\n                  showToastOnActiveTab(getRandomToastMessage());\n                }\n              } else {\n                // No scripting permission, fallback to clipboard notification\n                showToastOnActiveTab(getRandomToastMessage());\n              }\n            } catch (error) {\n              console.error(\"Error in auto-paste:\", error);\n              showToastOnActiveTab(getRandomToastMessage());\n            }\n          } else {\n            // AutoPaste is disabled, show clipboard notification\n            if (copied) {\n              showToastOnActiveTab(getRandomToastMessage());\n            } else {\n              showToastOnActiveTab(\"Failed to copy to clipboard. Check permissions.\");\n            }\n          }\n        } catch (error) {\n          console.error(\"Error handling prompt selection:\", error);\n          showToastOnActiveTab(\"Something went wrong. Please try again.\");\n        }\n      }\n    }\n  }\n});\n\n// Listen for messages from popup\nchrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n  console.log('Background script received message:', message);\n  \n  if (message.action === 'enableAutoPaste') {\n    // Just ensure the setting is saved in storage\n    chrome.storage.local.set({ autoPaste: true });\n    console.log('Auto-paste enabled');\n    sendResponse({ success: true });\n  } \n  else if (message.action === 'disableAutoPaste') {\n    // Just ensure the setting is saved in storage\n    chrome.storage.local.set({ autoPaste: false });\n    console.log('Auto-paste disabled');\n    sendResponse({ success: true });\n  }\n  else if (message.action === 'getTextToPromptEnabled') {\n    // Get the current text-to-prompt setting\n    chrome.storage.local.get(['textToPromptEnabled'], (result) => {\n      // Default to enabled if not set\n      const isEnabled = result.textToPromptEnabled !== undefined ? result.textToPromptEnabled : true;\n      sendResponse({ enabled: isEnabled });\n    });\n    return true; // Required for async response\n  }\n  \n  // This is required to use sendResponse asynchronously\n  return true;\n});\n\n// Add message listeners for the floating icon content script\nchrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n  // Get folders for the floating icon\n  if (message.action === 'getFolders') {\n    storageManager.getFolders().then(folders => {\n      // Transform folders to simple format with just id and name\n      const simpleFolders = folders.map(folder => ({\n        id: folder.id,\n        name: folder.name\n      }));\n      sendResponse({ folders: simpleFolders });\n    });\n    return true; // Indicates async response\n  }\n  \n  // Get current theme setting\n  if (message.action === 'getTheme') {\n    // Get current theme from storage\n    chrome.storage.local.get(['theme'], (result) => {\n      const theme = result.theme || { isDark: true };\n      sendResponse({ isDarkMode: theme.isDark });\n    });\n    return true; // Indicates async response\n  }\n  \n  // Create a new folder\n  if (message.action === 'createFolder') {\n    const folderName = message.name;\n    \n    if (!folderName) {\n      sendResponse({ success: false, error: 'Folder name is required' });\n      return true;\n    }\n    \n    storageManager.getFolders().then(folders => {\n      // Create a new folder\n      const newFolder: Folder = {\n        id: crypto.randomUUID(),\n        name: folderName,\n        prompts: []\n      };\n      \n      // Add the new folder to the list\n      folders.push(newFolder);\n      \n      // Save the updated folders\n      storageManager.saveFolders(folders).then(() => {\n        // Rebuild the context menu\n        rebuildContextMenu();\n        \n        // Notify all tabs about the folder update\n        chrome.tabs.query({}, tabs => {\n          tabs.forEach(tab => {\n            if (tab.id) {\n              chrome.tabs.sendMessage(tab.id, { action: 'foldersUpdated' });\n            }\n          });\n        });\n        \n        sendResponse({ success: true, folderId: newFolder.id });\n      });\n    });\n    \n    return true; // Indicates async response\n  }\n  \n  // Save a prompt from the floating icon\n  if (message.action === 'savePrompt') {\n    // Use an async IIFE to handle async operations\n    (async () => {\n      const { title, text, folderId } = message;\n      \n      if (!text || !folderId) {\n        sendResponse({ success: false, error: 'Text and folder ID are required' });\n        return;\n      }\n      \n      try {\n        const folders = await storageManager.getFolders();\n        \n        // Find the folder\n        const folderIndex = folders.findIndex(folder => folder.id === folderId);\n        \n        if (folderIndex === -1) {\n          sendResponse({ success: false, error: 'Folder not found' });\n          return;\n        }\n        \n        // Create a new prompt\n        const newPrompt: Prompt = {\n          id: crypto.randomUUID(),\n          title: title || 'Untitled Prompt',\n          text,\n          timestamp: new Date().toISOString()\n        };\n        \n        // Add the prompt to the folder\n        folders[folderIndex].prompts.push(newPrompt);\n        \n        // Save the updated folders\n        await storageManager.saveFolders(folders);\n        \n        // Try to rebuild the context menu, but don't block the response\n        try {\n          await rebuildContextMenu();\n        } catch (error) {\n          console.error('Error rebuilding context menu:', error);\n          // Continue anyway - this is non-critical\n        }\n        \n        // Show a success notification\n        const activeTab = _sender.tab;\n        if (activeTab?.id) {\n          showToastOnActiveTab('Prompt saved successfully!');\n        }\n        \n        sendResponse({ success: true });\n      } catch (error) {\n        console.error('Error saving prompt:', error);\n        sendResponse({ success: false, error: 'Failed to save prompt' });\n      }\n    })();\n    \n    return true; // Indicates async response\n  }\n});\n\n// Listen for theme changes from the popup\nchrome.storage.onChanged.addListener((changes, namespace) => {\n  if (namespace === 'local' && changes.theme) {\n    const newTheme = changes.theme.newValue;\n    \n    // Broadcast the theme change to all content scripts\n    chrome.tabs.query({}, (tabs) => {\n      tabs.forEach(tab => {\n        if (tab.id) {\n          chrome.tabs.sendMessage(tab.id, { \n            action: 'themeChanged', \n            isDarkMode: newTheme.isDark \n          }).catch(() => {\n            // Ignore errors for inactive tabs or restricted pages\n          });\n        }\n      });\n    });\n  }\n});\n"],"names":["CONTEXT_MENU_IDS","folderId","promptId","toastMessages","getRandomToastMessage","showToastOnActiveTab","message","tab","msg","TOAST_ID","cleanup","toast","e","existingToastById","iconSpan","textSpan","toastTimer","backupTimer","error","copyToClipboard","text","activeTab","result","textToCopy","textarea","success","rebuildContextMenu","folders","storageManager","regularFolders","f","importedFolders","folder","prompt","details","tabs","_a","tabId","url","scriptError","changes","info","title","match","foundPrompt","p","isAutoPasteEnabled","copied","results","activeElement","whiteSpace","selection","range","textNode","formattedText","inputElement","start","end","value","inputEvent","changeEvent","editors","cmInstance","cmElements","doc","cursor","aceEditor","instanceName","_sender","sendResponse","isEnabled","simpleFolders","theme","folderName","newFolder","folderIndex","newPrompt","namespace","newTheme"],"mappings":"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"}